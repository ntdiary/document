
原文地址：https://gitlab.com/help/workflow/gitlab_flow.md

* GitLab工作流
** 简介
使用git进行版本管理，使得分支和合并比早期的版本系统(如svn)容易得多。这也意味着可以支持多样的分支策略和工作流。这些也都改善了在git之前的使用方式。但大多数机构的工作流程要么定义不够清晰，要么太过复杂，或者并没有整合入问题追踪系统。基于此，我们提出了GitLab工作流作为明确的最佳实践。它整合了[[https://en.wikipedia.org/wiki/Feature-driven_development][功能驱动开发]]和带有问题追踪的[[http://martinfowler.com/bliki/FeatureBranch.html][功能分支]]。

刚从其它版本控制系统迁移到git时，大多数机构常会觉得很难找到一种高效的工作流。本文介绍了GitLab工作流，它将问题追踪系统整合到了git工作流中，也提供了一种简单、透明、有效的方式来使用git。

#+DOWNLOADED: https://gitlab.com/help/workflow/four_stages.png @ 2018-03-12 01:30:52
[[file:img/20180312013049.png]]

当转换为git时，你必须习惯于在和同事协作时会有三个步骤；而大多数版本控制系统仅需一步，从工作副本中提交到共享服务器中。在git中，你需要先把文件从工作区中加入到暂存区域，之后再提交到本地仓库中，第三步是把改动推送到远程共享仓库中。在习惯这三步之后，即可尝试分支模型。

#+DOWNLOADED: https://gitlab.com/help/workflow/messy_flow.png @ 2018-03-12 01:39:43
[[file:img/20180312013931.png]]

因为大多数机构在刚接触git时，并没有约定应该如何使用它，版本管理可能很快会变成一团乱麻。他们遇到最大的问题，可能是许多长期运行的分支中，都包含有部分版本变化，以致很难弄清楚自己应该在哪个分支上开发或将哪个分支部署到生产上。面对这种问题，常见的措施是采用标准化的模式，如[[http://nvie.com/posts/a-successful-git-branching-model/][git工作流]]和[[http://scottchacon.com/2011/08/31/github-flow.html][GitHub工作流]]。我们认为在此之上仍有改进的空间，并细化出了GitLab工作流。

** Git工作流及其问题
#+DOWNLOADED: https://gitlab.com/help/workflow/gitdashflow.png @ 2018-03-12 02:02:21
[[file:img/20180312020216.png]]

Git工作流是最早使用git分支功能的提议之一，并且受到了广泛关注。它支持一个master分支，一个单独的develop分支，同时支持诸如features、releases和hotfixes等分支。开发主要在develop分支中，然后移动到release分支，最后被合并到master分支中。Git工作流定义了一个很好的标准，但它的复杂性引入了两个问题。第一个问题是，开发人员必须使用develop分支而不是master分支，master分支只用来储存发布到生产环境的代码。然而通常默认分支名为master，且大多数分支来来自于master并合并到master分支中。因为很多工具自动将master分支作为默认分支并展示，所以你还要麻烦地切换到另外一个分支。第二个问题则是由hotfix和release分支带来的复杂性。这些分支可能对有些机构来说很不错，但对于更多数机构来说却是有害的。现在很多机构开始使用持续交付，意味着你的默认分支是可以被部署的。这意味着hostfix和release分支不能再很好的契合原有的使用场景(todo)。例如release分支的合并。尽管有特殊的工具来解决这个问题，但仍需要文档并加大了复杂性。开发者常会犯错误比如修改只合并到了master分支而没有合并到develop分支。造成这些错误的根本原因，是git工作流对于大多数使用场景来说太灵活了。而且做一次预发布并不意味着会自动做一次热修复。

** GitHub工作流——一个简化版的选择
#+DOWNLOADED: https://gitlab.com/help/workflow/github_flow.png @ 2018-03-12 10:29:07
[[file:img/20180312102904.png]]

GitHub工作流，作为一个简化版的Git工作流被提出。这个工作流只有一些feature分支和一个master分支，这很简单和干净。很多机构都成功地运用了它。Atlassian提出了一个类似的策略，不同的是他们衍合分支(todo)。把所有修改合并到master分支并部署，意味着你可以最大化地减少库存的代码量，这也与精益交付和可持续交付的最佳实践一致。然而这种工作流仍然有很多问题没有解决好，如忽略了部署、环境、预发布以及整合问题。在GitLab工作流中，对于这些问题，我们都有额外的指导。

** GitLab工作流之生产分支
#+DOWNLOADED: https://gitlab.com/help/workflow/production_branch.png @ 2018-03-12 11:50:49
[[file:img/20180312115045.png]]

GitHub工作流假定你在每次合并一个功能分支时，都会部署到生产上去。这对于一些Saas应用来说也许可以，但仍有很多场景并不适用。有时候你并不能精确的控制发布时间，比如一个IOS应用需要通过App Store的审核。又如当你有一个发布窗口时（在工作日上午10点到下午4点团队都在满负荷运转）,你又在其它时间合并了代码。在这些情况下，你需要新建一个production分支来追踪被部署的代码。你可以通过合并master分支到production分支来发布一个新版本。当你想知道生产上的是什么代码时， 只需要检出production分支来看一下即可，提交代码的时间也大致是发布时间，尤其是在自动部署生产分支的情况下。如果需要一个更确切的时间，你可以让你的发布脚本在每次发布时创建一个标签。这种工作流可以预防像git工作流中常见的过多的预发布、标签和合并现象。

** GitLab工作流之环境分支
#+DOWNLOADED: https://gitlab.com/help/workflow/environment_branches.png @ 2018-03-12 13:55:00
[[file:img/20180312135458.png]]

有一个随master分支自动更新的环境是个不错的主意。在这种场景下，这个环境的名字可能和分支名字不一样。假定你有一个模拟环境，一个预生产环境，和一个生产环境。此时master分支被部署到模拟环境上。当有人想要部署到预生产环境时，他们可以创建一个从master分支到预生产分支的合并请求，同理可以把预生产分支合并到生产分支来实现上线。这种提交仅向下游流动的工作流可以保证所有代码在全部环境中得到测试。如果你需要筛选出一次提交做热修复，通常可以在feature分支上开发，然后通过一个mr(merge request)合并到master分支中(此时不要删除feature分支)。如果master分支可以良好运行(如果你实现了持续发布，就会是这样)，即可以将其合并到其它分支中。如果因为太多的手工测试合并受阻的话，不得己时也可以发起从feature分支到其它下游分支的mr。

** GitLab工作流之版本分支
#+DOWNLOADED: https://gitlab.com/help/workflow/release_branches.png @ 2018-03-12 15:38:25
[[file:img/20180312153821.png]]

只有当你需要对外部按版本发布时，你可以使用release分支。这种场景下，每个分支包含一个小版本(2-3-stable，2-4-stable等等)。这些分支起始于master分支并尽可能晚地创建。尽可能晚地创建这些分支，是为了让你可以把bug修复应用到多个分支的时间最小化。在一个版本分支创建后，只有必要的Bug修复可以合并到版本分支中。如果可能的话，这些Bug修复首先要合并到master分支中然后再筛选到版本分支中。通过这种方式，你不用担心会忘记筛选它们到master分支中并且在后续版本中碰到相同的bug。这被称为 =上游优先= 原则，并且已被[[https://www.chromium.org/chromium-os/chromiumos-design-docs/upstream-first][Google]]和[[https://www.redhat.com/about/news/archive/2013/5/a-community-for-using-openstack-with-red-hat-rdo][Red Hat]]所实践。每次添加一个bug修复后，版本分支的补丁号会通过设定一个新标签来增加(服从[[http://semver.org/][Semantic Versioning]])。一些工程也会有个稳定分支，指向和最新的发布分支相同的提交。在这种工作流中，通常不会有生产分支(或git工作流里的master分支)。

** GitLab工作流之合并/拉取请求
#+DOWNLOADED: https://gitlab.com/help/workflow/mr_inline_comments.png @ 2018-03-12 16:39:18
[[file:img/20180312163914.png]]

合并请求(merge requests，即MR)或拉取请求(pull requests，即PR)创建于git管理应用中，并用于请求分配人员合并两个分支。GitHub和Bitbucket等工具命名为PR，因为第一步操作都是要拉取功能分支。GitLab等其它工具命名为MR，因为最后一步操作是来自于受让人的请求。本文中我们称这步操作为MR。

如果你在一个功能分支上工作了几个小时，建议你将中间成果分享给团队的其它成员。这可以通过创建一个MR来完成，这个MR不用分配给任何人，只需要在描述或评论中提到相关人员即可(/cc @mark @susan)。这意味着此次请求还没有准备好合并但欢迎反馈。你的团队成员可以在MR上做通用评论或者在具体行上使用行评论。MR也可以用做代码复审工具，如此便不再需要像Gerrit或reviewboard这些独立的复审工具。如果复审暴露出了一些缺点，任何人都可以提交并推送一个修复。通常做这件事儿的是MR/PR的创建人。当新的提交被推送到分支上时，MR/PR的不同之处也会自动更新。

当你觉得是时候合并代码时，你可以将它分配给了解你正在修改的代码的人并提醒你想要反馈的任何人。此后可以进行更多的反馈互动，在指定人员觉得结果合适时该分支将会被合并。如果指定人员觉得不合适，可以通过关闭MR来拒绝合并。

在GitLab中，通常会保护长期存在的分支(如master分支)，以便普通开发者不能修改这些受保护的分支。如此，当你想要合并修改到一个受保护的分支时，你需要将其指派给一个有权限的人。

** GitLab工作流之问题追踪

#+DOWNLOADED: https://gitlab.com/help/workflow/merge_request.png @ 2018-03-12 20:35:27
[[file:img/20180312203515.png]]

GitLab工作流让代码和问题追踪者之前的关系更加透明。

代码中任何重要的改变都应以一个问题开始，并描述清楚其预期目标。为每次代码更改注上原因并通知团队的每个人是很重要的事，这能帮助人们将一个功能分支的范围尽量的缩小。在GitLab中，每次对基本代码的改变都以在问题追踪系统中新建一个问题开始。如果还没有问题，应该在做重要工作时(花费超过1个小时)首先创建它。正常情况下，许多公司应该都会用到这个，因为这些问题都可以被用来作为竞赛评估。另外，建议问题的标题应尽量描述出预期的系统状况，如"作为管理员，我希望在移除用户时不会收到一个错误"会比"管理员不能移除用户"要好一些。

当你写代码时，你可以为相关的问题从master分支中新建一个分支出来。这个分支的名字可以以问题编号开始，如"15-require-a-password-to-change-it"。

当你在开发完，或者想要讨论代码时，你可以打开一个MR，可以用它来讨论修改代码或复审代码。因为你不会问题想要向你推送的分支中合并新的分支，所以打开一个MR需要手动操作，目标分支可以是一个长期存在的分支或者release分支。如果你打开了一个MR却没有分配给任何人，它将被视为 =工作中= 状态。这可以被用来讨论一些尚未准备好合并到master分支中的代码。专业提示：用 =[WIP]= 或 =[WIP:]= 作为问题标题的开头，可以防止它在完成之前被合并。

当作者认为代码已开发完时，可以把MR分配给复审人员。复审人员认为代码可以被主分支接受时可以按下合并按钮。此时代码会被合并而且稍后会生成一个合并提交记录，以便让这次合并记录能更清晰地展现。即使没有合并其它修改，合并请求也可以创建一次提交记录。git中称之为 =非快进= 。因为后面不会再被用到，功能分支在合并后可以被删除。在GitLab中你可以在合并时选择是否删除。

假如合并一个分支后，出了岔子且相关的问题被再次打开。我们仍可以使用之前的分支名字，因为那个分支在之前合并后已经被删除了。任何时候，一个问题都只能对应最多一个分支，而一个分支有时可以解决多个问题。

** 从MR中链接和关闭问题
#+DOWNLOADED: https://gitlab.com/help/workflow/close_issue_mr.png @ 2018-03-13 07:23:13
[[file:img/20180313072309.png]]

我们可以在提交信息或合并请求的描述中用到链接问题的功能，只要在其中提到相关的问题即可(如fixes #14, closes #67等等)。GitLab稍后便会创建指向相关问题的链接，并且会在相关问题下创建指回本次合并请求的链接。

这些问题在代码合并到默认分支时便会被关闭。

如果你只是想要引用到某个问题但并不想关闭它，你可以这么做："鸭子类型更易被接受。#12"。

如果你有个跨越多个仓库的问题，最好在每个仓库中都创建一个问题然后把这些问题都链接到这个父问题上。

** 使用变基来整合提交
#+DOWNLOADED: https://gitlab.com/help/workflow/rebase.png @ 2018-03-13 08:03:38
[[file:img/20180313080332.png]]

在git中，你可以使用交互式的变基(rebaes -i)把多次提交整合到一次提交中并重排其顺序。你也可以通过web端[[https://gitlab.com/help/user/project/merge_requests/fast_forward_merge.md][在合并前变基]]。这个功能可以用于将针对某个小改动的多次提交替换为一次提交，或者想让提交的顺序更符合逻辑。然而你不应该在已经推送到远程的提交上应用变基。一些人可能已经引用或者拣选了它们。执行变基，会同时改变相关提交的识别码(SHA-1)，而容易引起人的困惑。如果相关人员已经复审过你的代码，那在你把所有修改都合并成一个提交时，他们将很难区分出哪些是你复审之后又新提交的修改。另一个不推荐使用变基的原因，是它会丢失作者信息。也许有人创建了一个MR，另一个推送了一个提交来改进它，然后第三个人合并了这次MR。此时将所有的提交变基到一个提交会使作者不能被正确地标识并分担[[https://git-scm.com/docs/git-blame][git追责]]。

我们鼓励经常提交并推送到远程分支，以便让其它人知道所有人的工作状态。这会导致每次改动都有大师的提交，以致提交历史会变得难以理解。但有稳定识别符的好处要胜过这个缺点。如果想要理解上下文中的变化，我们可以查看合并提交，它会把所有的提交分组显示在一起。

在你把多次提交从功能分支合并到主分支中后，通常很难撤销这个操作。如果你是把所有提交都清理成了一个提交，那么你可以执行回退这次提交即可，只是我们建议你不要在已经推送到远程的提交上变基。幸运的是，git中可以回退一段时间之内的合并，只是这需要你想回退的提交中必须有特定的合并提交。如果你回退一次合并后又后悔了，你可以回退这次回退而不是再次合并，因为git不会允许你再次合并代码。

手动合并时加上 =--no-ff= 参数的一个好处是允许你回退这次提交。git管理软件一般在你接受一次合并请求时都会创建一次合并提交。

** 不要使用变基来排序
#+DOWNLOADED: https://gitlab.com/help/workflow/merge_commits.png @ 2018-03-14 04:55:42
[[file:img/20180314045536.png]]

在git中，提交到主分支之后，你在功能分支中可以通过变基这些提交来重排它们。这可以防止你在合并主分支到功能分支时创建一次合并提交，从而保持一条良好的线性提交历史。然而，和上面的清理提交一样，你不应该变基那些已经推送到远程服务器的提交。因为不可能变基那些已经分享给团队的处理工作中的部分。当使用变基来保证分支更新时，你需要[[https://blogs.atlassian.com/2013/10/git-team-workflows-merge-or-rebase/][不停地解决一些类似的冲突]]。有时你可能要重复那些已经做过的决定(一而再再而三)，如果不使用变基的话，你只需要解决一次冲突就能搞定了。应该有一种更好的方式来避免大量的合并提交。
